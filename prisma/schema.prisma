generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum CompanyStatus {
  ACTIVE
  BLOCKED
  ARCHIVED
}

enum VerificationStatus {
  UNVERIFIED
  VERIFIED
  REJECTED
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  REGISTER
  ARCHIVE_COMPANY
  UNARCHIVE_COMPANY
  BLOCK_COMPANY
  UNBLOCK_COMPANY
  USER_BLOCK
  USER_UNBLOCK
  RESET_PASSWORD
  PAYMENT_INITIATED
  PAYMENT_SUBMITTED
  PAYMENT_CONFIRMED
  PAYMENT_FAILED
  TRANSACTION_CRYPTO
  HOLD_CREATED
  HOLD_RELEASED
  DOCUMENT_UPLOAD
  DOCUMENT_DELETE
  VERIFY_COMPANY
  REJECT_COMPANY
}

enum AuditEntity {
  USER
  COMPANY
  PURCHASE
  CREDIT
  DOCUMENT
  SYSTEM
  PAYMENT
}

enum PaymentStatus {
  PENDING
  SUBMITTED
  CONFIRMED
  FAILED
}

enum PurchaseStatus {
  PENDING_PAYMENT
  PAID
  COMPLETED
  CANCELED
}

enum CreditPoolStatus {
  DRAFT
  ACTIVE
  PAUSED
  CLOSED
}

enum CreditPoolVisibility {
  PUBLIC
  PRIVATE
}

enum UserStatus {
  PENDING_VERIFICATION
  ACTIVE
  DISABLED
}

model User {
  id                      String                     @id @default(cuid())
  email                   String                     @unique
  hashedPassword          String?
  role                    String                     @default("COMPANY")
  name                    String?
  emailVerifiedAt         DateTime?
  status                  UserStatus                 @default(PENDING_VERIFICATION)
  createdAt               DateTime                   @default(now())
  updatedAt               DateTime                   @updatedAt
  companyId               String?
  company                 Company?                   @relation(fields: [companyId], references: [id])
  brokerId                String?
  broker                  Broker?                    @relation(fields: [brokerId], references: [id])
  accountantClients       AccountantClient[]
  uploadedDocuments       Document[]
  auditLogs               AuditLog[]
  purchases               Purchase[]
  emailVerificationTokens EmailVerificationToken[]
}

model Company {
  id                 String             @id @default(cuid())
  legalName          String
  ein                String?            @unique
  state              String?
  contactEmail       String
  taxLiability       Decimal?
  targetCloseYear    Int?
  ownerId            String?
  walletAddress      String?
  status             CompanyStatus      @default(ACTIVE)
  verificationStatus VerificationStatus @default(UNVERIFIED)
  verificationNote   String?
  archivedAt         DateTime?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  deletedAt          DateTime?
  users              User[]
  purchaseOrders     PurchaseOrder[]
  purchases          Purchase[]
  documents          Document[]
  holds              Hold[]
  auditLogs          AuditLog[]
  accountantLinks    AccountantClient[]
}

model AccountantClient {
  id           String   @id @default(cuid())
  accountantId String
  companyId    String
  createdAt    DateTime @default(now())
  accountant   User     @relation(fields: [accountantId], references: [id])
  company      Company  @relation(fields: [companyId], references: [id])

  @@unique([accountantId, companyId])
}

model EmailVerificationToken {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  
  @@index([userId])
  @@index([token])
}

model CreditInventory {
  id               String          @id @default(cuid())
  creditType       String
  taxYear          Int
  jurisdiction     String?
  stateRestriction String?
  faceValueUSD     Decimal
  minBlockUSD      Decimal
  pricePerDollar   Decimal
  availableUSD     Decimal
  closeBy          DateTime?
  brokerName       String?
  notes            String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  status           String          @default("ACTIVE")
  brokerRef        String?
  source           String?
  importedAt       DateTime?
  holds            Hold[]
  purchaseOrders   PurchaseOrder[]
  purchases        Purchase[]
  
  @@unique([brokerRef], map: "creditinventory_brokerref_unique")
}

model Hold {
  id          String          @id @default(cuid())
  inventoryId String
  companyId   String
  amountUSD   Decimal
  expiresAt   DateTime
  createdAt   DateTime        @default(now())
  status      String          @default("ACTIVE")
  inventory   CreditInventory @relation(fields: [inventoryId], references: [id])
  company     Company         @relation(fields: [companyId], references: [id])
}

model PurchaseOrder {
  id                    String            @id @default(cuid())
  companyId             String
  inventoryId           String
  amountUSD             Decimal
  pricePerDollar        Decimal
  subtotalUSD           Decimal
  feesUSD               Decimal
  totalUSD              Decimal
  stripeSessionId       String?
  status                String            @default("PENDING_PAYMENT")
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  complianceStatus      String            @default("MISSING")
  brokerStatus          String            @default("PENDING")
  closingCertificateUrl String?
  brokerPackageUrl      String?
  company               Company           @relation(fields: [companyId], references: [id])
  inventory             CreditInventory   @relation(fields: [inventoryId], references: [id])
}

model Document {
  id           String   @id @default(cuid())
  companyId    String
  company      Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  filename     String
  mimeType     String
  sizeBytes    Int
  storagePath  String
  uploadedById String?
  uploadedBy   User?    @relation(fields: [uploadedById], references: [id])
  createdAt    DateTime @default(now())
  deletedAt    DateTime?
  
  @@index([companyId])
}

model AuditLog {
  id          String      @id @default(cuid())
  timestamp   DateTime    @default(now())
  actorId     String?
  actorEmail  String?
  action      AuditAction @default(CREATE)
  entity      AuditEntity @default(SYSTEM)
  entityId    String?
  details     Json?
  companyId   String?
  ip          String?
  userAgent   String?
  txHash      String?
  amountUSD   Decimal?    @db.Decimal(18,4)
  actor       User?       @relation(fields: [actorId], references: [id])
  company     Company?    @relation(fields: [companyId], references: [id])

  @@index([timestamp])
  @@index([entity, entityId])
  @@index([companyId])
  @@index([actorId])
  @@index([action])
}

model PaymentLog {
  id              String        @id @default(cuid())
  userId          String?
  companyId       String?
  purchaseOrderId String?
  chainId         Int
  tokenAddress    String
  toAddress       String
  amountRaw       String
  feeBps          Int
  feeRaw          String
  totalRaw        String
  txHash          String?
  status          PaymentStatus @default(PENDING)
  meta            Json?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([userId, companyId, status])
}

model Purchase {
  id              String          @id @default(cuid())
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  accountantId    String
  companyId       String
  taxCreditId     String
  nominalValueUSD Decimal         @db.Decimal(18,2)
  pricePerDollar  Decimal         @db.Decimal(5,4)
  totalUSD        Decimal         @db.Decimal(18,2)
  status          PurchaseStatus  @default(PENDING_PAYMENT)
  payment         Payment?
  company         Company         @relation(fields: [companyId], references: [id])
  inventory       CreditInventory @relation(fields: [taxCreditId], references: [id])
  accountant      User            @relation(fields: [accountantId], references: [id])

  @@index([accountantId])
  @@index([companyId])
  @@index([taxCreditId])
}

model Payment {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  purchaseId  String        @unique
  network     String
  token       String
  amountUSD   Decimal       @db.Decimal(18,2)
  feeUSD      Decimal       @db.Decimal(18,2)
  txHash      String
  status      PaymentStatus @default(SUBMITTED)
  purchase    Purchase      @relation(fields: [purchaseId], references: [id])
}

model Broker {
  id          String             @id @default(cuid())
  name        String
  legalName   String?
  email       String?            @unique
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  taxId       String?
  state       String?
  country     String?
  users       User[]
  creditPools BrokerCreditPool[]
}

model BrokerCreditPool {
  id                     String               @id @default(cuid())
  brokerId               String
  broker                 Broker               @relation(fields: [brokerId], references: [id])
  programName            String
  creditYear             Int
  creditType             String
  jurisdiction           String
  programCode            String?
  registryId             String?
  totalFaceValueUsd      Decimal              @db.Decimal(18,2)
  availableFaceValueUsd  Decimal              @db.Decimal(18,2)
  minBlockUsd            Decimal              @db.Decimal(18,2)
  pricePerDollar         Decimal              @db.Decimal(6,4)
  visibility             CreditPoolVisibility @default(PUBLIC)
  status                 CreditPoolStatus     @default(DRAFT)
  offerStartDate         DateTime?
  offerExpiryDate        DateTime?
  expectedSettlementDays Int?
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt
}

// TODO: Run `npm run db:push` to apply schema changes to the database
