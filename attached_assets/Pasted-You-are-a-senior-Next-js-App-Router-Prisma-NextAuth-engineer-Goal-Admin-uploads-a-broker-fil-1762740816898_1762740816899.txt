You are a senior Next.js (App Router) + Prisma + NextAuth engineer.
Goal: Admin uploads a broker file (CSV/XLSX) → server parses & validates → creates/updates Tax Credit cards → credits appear on Marketplace for all roles (Admin/Accountant/Company).
Implement EXACTLY as below.

ASSUMPTIONS
- Next.js 14 App Router
- Prisma Client exported from "@/lib/db"
- NextAuth config exported from "@/lib/auth"; role in session.user.role
- Tailwind present
- Marketplace already renders TaxCredit from DB (we’ll ensure query)

===============================================================================
1) PRISMA — extend TaxCredit for imports & idempotency
Open prisma/schema.prisma and INSERT/MERGE this model (do not delete existing fields; only add missing ones):

model TaxCredit {
  id          String   @id @default(cuid())
  code        String               // e.g. "C48E", "45Q", "PTC"
  year        Int
  state       String?
  faceValue   Decimal  @db.Decimal(18,2)  // total pool face value
  available   Decimal  @db.Decimal(18,2)  // amount available
  minBlock    Decimal  @db.Decimal(18,2)  // minimum purchase block
  price       Decimal  @db.Decimal(6,4)   // price per $1 face (e.g., 0.8900)
  discountPct Decimal? @db.Decimal(5,2)
  status      String   @default("ACTIVE") // ACTIVE | INACTIVE
  notes       String?

  // NEW import metadata (for idempotent upserts)
  brokerRef   String?               // unique row id from broker
  source      String?               // batch tag (e.g., ACME_JAN2026)
  importedAt  DateTime? @default(now())

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([code, year])
  @@unique([brokerRef], map: "taxcredit_brokerref_unique")
}

Then run:
npx prisma generate
npx prisma db push

===============================================================================
2) DEPENDENCIES (parsing/validation)
Run:
npm i xlsx zod

===============================================================================
3) ADMIN-ONLY API — upload, parse, validate, upsert
Create file: app/api/admin/credits/upload/route.ts

import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/db";
import * as XLSX from "xlsx";
import { z } from "zod";

const Row = z.object({
  brokerRef: z.string().optional(),
  source: z.string().optional(),
  code: z.string().min(2),
  year: z.coerce.number().int().min(2000).max(2100),
  state: z.string().optional(),
  faceValue: z.coerce.number().positive(),
  available: z.coerce.number().nonnegative(),
  minBlock: z.coerce.number().positive(),
  price: z.coerce.number().min(0.5).max(1.0),
  discountPct: z.coerce.number().min(0).max(100).optional(),
  status: z.enum(["ACTIVE","INACTIVE"]).default("ACTIVE"),
  notes: z.string().optional(),
});
const Rows = z.array(Row).min(1);

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user as any)?.role !== "ADMIN") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const form = await req.formData();
  const file = form.get("file") as File | null;
  const declaredSource = (form.get("source") as string | null) ?? undefined;
  if (!file) return NextResponse.json({ error: "No file provided" }, { status: 400 });

  const ab = await file.arrayBuffer();
  const wb = XLSX.read(new Uint8Array(ab), { type: "array" });
  const sheet = wb.Sheets[wb.SheetNames[0]];
  const raw = XLSX.utils.sheet_to_json<any>(sheet, { defval: "" });

  // Flexible header mapping
  const norm = (r:any,k:string) => r[k] ?? r[k.toLowerCase()] ?? r[k.toUpperCase()];
  const rows = raw.map((r:any) => ({
    brokerRef: norm(r,"brokerRef") || norm(r,"BrokerRef") || norm(r,"REF") || undefined,
    source: declaredSource || norm(r,"source") || norm(r,"Source") || undefined,
    code: String(norm(r,"code") || norm(r,"Credit") || norm(r,"Type") || "").trim(),
    year: norm(r,"year") || norm(r,"Year"),
    state: norm(r,"state") || norm(r,"State") || undefined,
    faceValue: norm(r,"faceValue") || norm(r,"FaceValue") || norm(r,"Face"),
    available: norm(r,"available") || norm(r,"Available"),
    minBlock: norm(r,"minBlock") || norm(r,"MinBlock") || norm(r,"Min"),
    price: norm(r,"price") || norm(r,"Price"),
    discountPct: norm(r,"discountPct") || norm(r,"Discount") || undefined,
    status: (norm(r,"status") || "ACTIVE") as string,
    notes: norm(r,"notes") || norm(r,"Notes") || undefined,
  }));

  const parsed = Rows.safeParse(rows);
  if (!parsed.success) {
    return NextResponse.json({ error: "Validation failed", issues: parsed.error.flatten() }, { status: 400 });
  }

  let created = 0, updated = 0;
  await prisma.$transaction(async (tx) => {
    for (const r of parsed.data) {
      if (r.brokerRef) {
        const exists = await tx.taxCredit.findUnique({ where: { brokerRef: r.brokerRef } });
        if (exists) {
          await tx.taxCredit.update({
            where: { brokerRef: r.brokerRef },
            data: {
              code: r.code, year: r.year, state: r.state ?? null,
              faceValue: r.faceValue, available: r.available, minBlock: r.minBlock,
              price: r.price, discountPct: r.discountPct ?? null,
              status: r.status, notes: r.notes ?? null,
              source: r.source, importedAt: new Date(),
            }
          });
          updated++;
        } else {
          await tx.taxCredit.create({
            data: {
              brokerRef: r.brokerRef, source: r.source,
              code: r.code, year: r.year, state: r.state ?? null,
              faceValue: r.faceValue, available: r.available, minBlock: r.minBlock,
              price: r.price, discountPct: r.discountPct ?? null,
              status: r.status, notes: r.notes ?? null,
            }
          });
          created++;
        }
      } else {
        // No brokerRef: naive match to avoid duplicates
        const exists = await tx.taxCredit.findFirst({
          where: { code: r.code, year: r.year, price: r.price, minBlock: r.minBlock }
        });
        if (exists) {
          await tx.taxCredit.update({
            where: { id: exists.id },
            data: {
              state: r.state ?? null, faceValue: r.faceValue, available: r.available,
              discountPct: r.discountPct ?? null, status: r.status, notes: r.notes ?? null,
              source: r.source, importedAt: new Date(),
            }
          });
          updated++;
        } else {
          await tx.taxCredit.create({
            data: {
              code: r.code, year: r.year, state: r.state ?? null,
              faceValue: r.faceValue, available: r.available, minBlock: r.minBlock,
              price: r.price, discountPct: r.discountPct ?? null,
              status: r.status, notes: r.notes ?? null, source: r.source,
            }
          });
          created++;
        }
      }
    }
  });

  return NextResponse.json({ ok: true, counts: { created, updated } });
}

===============================================================================
4) ADMIN UI — file upload form on Inventory page
Edit app/admin/inventory/page.tsx (or the main inventory server page) to render a client uploader.

If it’s a Server Component, create: app/admin/inventory/UploadClient.tsx

"use client";
import { useState } from "react";

export default function UploadClient() {
  const [file, setFile] = useState<File|null>(null);
  const [source, setSource] = useState("");
  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState<string|null>(null);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!file) return;
    setBusy(true); setMsg(null);
    const fd = new FormData();
    fd.append("file", file);
    if (source) fd.append("source", source);
    const res = await fetch("/api/admin/credits/upload", { method: "POST", body: fd });
    const data = await res.json();
    setBusy(false);
    if (!res.ok) { setMsg(data.error || "Import failed"); return; }
    setMsg(`Imported: +${data.counts?.created || 0}, updated: ${data.counts?.updated || 0}`);
  }

  return (
    <form onSubmit={onSubmit} className="rounded-xl bg-[#0f1a2b] border border-white/10 p-4 space-y-3">
      <div className="text-lg font-semibold">Import broker file (.xlsx / .csv)</div>
      <div className="flex flex-col sm:flex-row gap-3 items-start sm:items-end">
        <div>
          <label className="block text-sm mb-1">File</label>
          <input type="file" accept=".xlsx,.xls,.csv" onChange={e=>setFile(e.target.files?.[0] ?? null)} required />
        </div>
        <div>
          <label className="block text-sm mb-1">Source tag (optional)</label>
          <input value={source} onChange={e=>setSource(e.target.value)} placeholder="ACME_JAN2026"
                 className="rounded-md bg-black/30 border border-white/10 px-3 py-2" />
        </div>
        <button disabled={busy || !file} className="rounded-md bg-emerald-500 text-black px-4 py-2 font-semibold">
          {busy ? "Importing..." : "Import"}
        </button>
      </div>
      {msg && <p className="text-sm opacity-80">{msg}</p>}
    </form>
  );
}

Then include it in app/admin/inventory/page.tsx:

import UploadClient from "./UploadClient";
...
return (
  <div className="space-y-6">
    <div className="flex items-center justify-between">
      <h1 className="text-3xl font-bold">Inventory Management</h1>
    </div>
    <UploadClient />
    {/* existing inventory list below */}
  </div>
);

===============================================================================
5) RBAC — protect admin routes
If not set, add middleware to restrict /admin and /api/admin/** to ADMIN.

middleware.ts

import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

export async function middleware(req: any) {
  const p = req.nextUrl.pathname;
  if (p.startsWith("/admin") || p.startsWith("/api/admin")) {
    const token = await getToken({ req });
    if (!token || token.role !== "ADMIN") {
      if (p.startsWith("/api/")) return new NextResponse("Unauthorized", { status: 401 });
      return NextResponse.redirect(new URL("/login", req.url));
    }
  }
  return NextResponse.next();
}
export const config = { matcher: ["/admin/:path*", "/api/admin/:path*"] };

===============================================================================
6) MARKETPLACE — ensure query picks up new credits
In your marketplace data loader (RSC or API used by all roles), use:

const credits = await prisma.taxCredit.findMany({
  where: { status: "ACTIVE", available: { gt: 0 } },
  orderBy: [{ code: "asc" }, { year: "desc" }],
});

Render cards from this result; no role restriction (marketplace is global).

===============================================================================
7) BROKER FILE TEMPLATE (share with partners)
Accept .xlsx or .csv with headers (case-insensitive):
brokerRef, source, code, year, state, faceValue, available, minBlock, price, discountPct, status, notes

Example rows:
BRK-0001, ACME_JAN2026, C48E, 2025, CA, 300000, 285000, 5000, 0.89, 11.0, ACTIVE, Energy storage portfolio
BRK-0002, ACME_JAN2026, C48C, 2025, TX, 750000, 750000, 10000, 0.90, 10.0, ACTIVE, Solar utility-scale

Tip: Using brokerRef enables idempotent updates (no duplicates on re-import).

===============================================================================
8) TEST CHECKLIST
- Login as ADMIN → /admin/inventory → upload .xlsx/.csv → see “Imported: +X, updated: Y”
- Open /marketplace as Admin/Accountant/Company → new credits visible
- Re-import same file with changed numbers → rows update, not duplicate
- Set status=INACTIVE in file → re-import → item disappears from marketplace (still in DB)
- Non-ADMIN cannot reach /admin or /api/admin/credits/upload

DONE — Admin file import → automatic TaxCredit create/update → marketplace ready for all roles.