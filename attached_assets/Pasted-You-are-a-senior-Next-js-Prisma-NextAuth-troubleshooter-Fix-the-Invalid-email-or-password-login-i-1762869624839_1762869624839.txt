You are a senior Next.js/Prisma/NextAuth troubleshooter. Fix the ‚ÄúInvalid email or password‚Äù login issue in the SuVerse Dashboard repo on Replit. Do everything end-to-end and show a concise summary of what you changed and why.

GOALS
1) Diagnose why all logins fail and fix it.
2) Make failures observable: structured server logs with clear REASONS (NOT to the client).
3) Ensure admin account exists and can log in.
4) Health checks + self-tests that run in the Replit environment.

CONTEXT (expected stack)
- Next.js (App Router), Prisma (PostgreSQL), NextAuth Credentials provider.
- Replit Secrets used for env.
- We recently reset DB and changed secrets. Admin user may be gone.
- Generic UI error: ‚ÄúInvalid email or password‚Äù (client shows same for all failures).

TASKS

A) Verify environment & config
1. Open `lib/env.ts` (or equivalent). Add a safe getter for auth env with Zod:
   - NEXTAUTH_SECRET: z.string().min(16)
   - NEXTAUTH_URL: z.string().url()
   - DATABASE_URL: z.string().url()
   - SESSION_SECRET (if used): z.string().min(16).optional()
   Log warnings (server console) if any are missing, with prefix `[auth:env]`.
2. Ensure NEXTAUTH_URL matches the current Replit URL (e.g. https://<app>.spock.replit.dev). If it doesn‚Äôt, update the Replit Secret and restart.

B) Inspect auth implementation
1. Locate NextAuth config (e.g., `app/api/auth/[...nextauth]/route.ts`).
2. Ensure only ONE hash algo is used. If passwords were hashed with bcrypt previously, verify we still use bcrypt compare:
   - import bcrypt; compare with `await bcrypt.compare(plain, hash)`
   - If code uses argon2/scrypt now but DB has bcrypt hashes, log reason `[auth:reason]=HASH_MISMATCH_SCHEME` and switch back to bcrypt.
3. Confirm we normalize emails consistently (trim + lowercase) both when creating and when logging in.
4. Check CSRF/COOKIE settings:
   - cookies should NOT be `secure: true` on plain HTTP (Replit preview). Use `secure: process.env.NODE_ENV === 'production'`.
   - Set `trustHost: true` in NextAuth options for non-standard hosts.
5. If there is a custom rate limiter/lockout, verify it‚Äôs not perma-locking everyone. If lockout state exists, clear it for the test admin and lower thresholds.

C) Add structured diagnostics (server-side only)
1. Wrap the Credentials authorize() logic and add a tiny helper `logAuth(event, data)` that prints ONE JSON line:
   - prefix: `[auth]`
   - fields: stage, emailMasked, reasonCode, ip, ua, ts
   - DO NOT log raw passwords or full emails. Mask as `jo***@domain.com`.
2. Typical reasonCode values to set:
   - USER_NOT_FOUND
   - HASH_MISMATCH
   - HASH_MISMATCH_SCHEME
   - INVALID_PASSWORD
   - ENV_INVALID
   - DB_ERROR
   - CSRF_ERROR
   - COOKIE_SECURE_MISCONFIG
   - RATE_LIMITED
3. Ensure client still shows the generic ‚ÄúInvalid email or password‚Äù, but server logs tell the truth.

D) Seed/restore the admin user
1. Create `prisma/seed.ts` (or update) to upsert an admin:
   - email: `admin@suverse.app`
   - name: `Admin User`
   - role: `ADMIN`
   - password: `Admin$12345` (hash with *bcrypt* 10‚Äì12 rounds)
2. Add npm script `"seed": "tsx prisma/seed.ts"`. Run `npx prisma generate && npx prisma migrate deploy && npm run seed`.
3. After seeding, verify the `User` table actually stores a bcrypt hash (prefix `$2`).

E) Health routes for quick checks
1. Add `app/api/health/auth/route.ts` that returns JSON:
   - `envOk` (NEXTAUTH_URL/SECRET/DATABASE_URL present),
   - `dbOk` (simple SELECT 1 via Prisma),
   - `hasAdmin` (boolean by email),
   - `hashAlgo` detected hint from stored admin hash (`bcrypt` if `$2`).
2. Add `app/api/test-login/route.ts` (POST) to attempt a server-side login with body {email,password} using the same validation as NextAuth (do NOT set cookies). Return `{ok:true}` if bcrypt.compare passes; otherwise `{ok:false, reason}`. This is for diagnostics only; restrict it to Replit env by checking `process.env.REPL_ID`.

F) Fix common pitfalls (apply as needed)
- If the `User` model uses a different field for password (e.g., `passwordHash`), make sure login reads the correct column.
- Ensure Prisma uses the same DB pointed by `DATABASE_URL` as the deployment (not a stale local file).
- If we recently changed `NEXTAUTH_SECRET`, invalidate old sessions by clearing the session table. Add a note in logs.

G) QA / Self-tests to run now
1. Restart the project to reload secrets.
2. Call health:
   - `curl -s https://<app>.spock.replit.dev/api/health/auth | jq .`
3. Test login API:
   - `curl -s -X POST https://<app>.spock.replit.dev/api/test-login -H "Content-Type: application/json" -d '{"email":"admin@suverse.app","password":"Admin$12345"}'`
   Expect `{ok:true}`.
4. Open `/login`, try:
   - admin@suverse.app / Admin$12345
   - Observe `[auth]` logs; there must be no ERROR reason codes.
5. Document the root cause detected and the file diffs.

H) Deliverables
- Patched NextAuth config with robust diagnostics and correct hashing.
- Seeded admin account with known credentials.
- `/api/health/auth` and `/api/test-login` routes.
- One short summary in Markdown: root cause, changes made, how to rotate admin password, and instructions to update secrets for production (set `NEXTAUTH_URL` to the final domain; set cookies secure).

IMPORTANT
- Never print secrets or raw passwords in logs/responses.
- Keep client error generic; put details only in server logs.
- If you modify any env, update Replit Secrets and restart.

At the end, output:
- ‚úÖ Root cause(s) found
- üîß Files changed
- üß™ Test outputs (health + test-login curl)
- üë§ Admin credentials (email only; say password was set to the known value without printing it)
- üìã Next steps for production hardening